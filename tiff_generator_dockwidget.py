# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PreAndPostFireTiffGeneratorDockWidget
                                 A QGIS plugin
 This Plugin creates a Pre and Post Fire Tiff file depending on the client input
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-03-20
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Diego - Fire2A
        email                : diego@fire2a.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, QDate, Qt
from qgis.core import QgsProject, QgsVectorLayer, QgsFeature, QgsGeometry, QgsPointXY, QgsRasterLayer
from qgis.gui import QgsMapToolEmitPoint
import ee
import tempfile
import requests

# Cargar la UI generada con Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'tiff_generator_dockwidget_base.ui'))

class FireIgnitionTool(QgsMapToolEmitPoint):
    def __init__(self, iface, callback):
        super().__init__(iface.mapCanvas())
        self.iface = iface
        self.canvas = iface.mapCanvas()
        self.callback = callback
        self.setCursor(Qt.CrossCursor)
        print("üî• FireIgnitionTool activado. Haz clic en el mapa para seleccionar el punto de ignici√≥n.")

    def canvasReleaseEvent(self, event):
        point = self.toMapCoordinates(event.pos())
        if point:
            print(f"üìç Punto de ignici√≥n seleccionado: {point.x()}, {point.y()}")
            self.callback(point)
            self.canvas.unsetMapTool(self)
            print("üîÑ Herramienta desactivada despu√©s de la selecci√≥n.")
        else:
            print("‚ö†Ô∏è No se pudo obtener un punto de ignici√≥n.")

class PreAndPostFireTiffGeneratorDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()

    def __init__(self, iface, parent=None):
        super(PreAndPostFireTiffGeneratorDockWidget, self).__init__(parent)
        self.iface = iface
        self.setupUi(self)

        # UI Setup
        self.setWindowTitle("Generador de TIFF de Incendios")
        layout = QtWidgets.QVBoxLayout()

        # Punto de ignici√≥n
        self.label_point = QtWidgets.QLabel("Punto de ignici√≥n: No seleccionado")
        self.btn_select_point = QtWidgets.QPushButton("Seleccionar punto en el mapa")
        self.btn_select_point.clicked.connect(self.select_point)

        # Fechas
        self.label_start_date = QtWidgets.QLabel("Fecha de inicio:")
        self.start_date = QtWidgets.QDateEdit()
        self.start_date.setCalendarPopup(True)
        self.start_date.setDate(QDate.currentDate())

        self.label_end_date = QtWidgets.QLabel("Fecha de t√©rmino:")
        self.end_date = QtWidgets.QDateEdit()
        self.end_date.setCalendarPopup(True)
        self.end_date.setDate(QDate.currentDate())

        # √Årea o longitud del recuadro
        self.label_area = QtWidgets.QLabel("√Årea estimada del incendio (ha) o longitud del recuadro (m):")
        self.area_input = QtWidgets.QDoubleSpinBox()
        self.area_input.setRange(0, 10000)
        self.area_input.setSuffix(" ha")

        # Bot√≥n para generar el TIFF
        self.btn_generate = QtWidgets.QPushButton("Generar TIFF")
        self.btn_generate.clicked.connect(self.generate_tiff)

        # Agregar widgets al layout
        layout.addWidget(self.label_point)
        layout.addWidget(self.btn_select_point)
        layout.addWidget(self.label_start_date)
        layout.addWidget(self.start_date)
        layout.addWidget(self.label_end_date)
        layout.addWidget(self.end_date)
        layout.addWidget(self.label_area)
        layout.addWidget(self.area_input)
        layout.addWidget(self.btn_generate)

        container = QtWidgets.QWidget()
        container.setLayout(layout)
        self.setWidget(container)

        self.ignition_point = None
        self.ee_initialize()

    def ee_initialize(self):
        try:
            ee.Initialize()
        except Exception as e:
            print(f"Error al inicializar Google Earth Engine: {e}")

    def select_point(self):
        print("üõ† Activando herramienta de selecci√≥n de punto de ignici√≥n...")
        self.tool = FireIgnitionTool(self.iface, self.set_point)
        self.iface.mapCanvas().setMapTool(self.tool)
        self.iface.mapCanvas().refresh()

    def set_point(self, point):
        if point:
            self.ignition_point = point
            self.label_point.setText(f"Punto de ignici√≥n: {point.x()}, {point.y()}")
            print(f"‚úÖ Punto de ignici√≥n confirmado: {point.x()}, {point.y()}")
        else:
            print("‚ö†Ô∏è Error: No se captur√≥ un punto v√°lido.")

    def generate_tiff(self):
        if not self.ignition_point:
            print("‚ö†Ô∏è No se ha seleccionado un punto de ignici√≥n.")
            self.label_point.setText("Selecciona un punto de ignici√≥n primero")
            return

        start_date = self.start_date.date().toString("yyyy-MM-dd")
        end_date = self.end_date.date().toString("yyyy-MM-dd")
        buffer_distance = self.area_input.value() * 100
        print("üöÄ Iniciando generaci√≥n de im√°genes pre y post incendio...")

        self.get_fire_images(start_date, end_date, buffer_distance)

    def applyScaleFactors(self, image):
        """
        Applies scale factors to Landsat Collection 2 images.

        Parameters:
        image (ee.Image): Input Landsat image.

        Returns:
        ee.Image: Scaled image with reflectance corrections applied.
        """
        opticalBands = image.select('SR_B.*').multiply(0.0000275).add(-0.2)

        hasST_B10 = image.bandNames().contains('ST_B10')
        hasST_B6 = image.bandNames().contains('ST_B6')

        ST_B10 = ee.Algorithms.If(hasST_B10, image.select('ST_B10'), ee.Image(0).rename('ST_B10'))
        ST_B6 = ee.Algorithms.If(hasST_B6, image.select('ST_B6'), ee.Image(0).rename('ST_B6'))

        return image.addBands(opticalBands, overwrite=True).addBands(ee.Image(ST_B10), overwrite=True).addBands(ee.Image(ST_B6), overwrite=True)

    def maskClouds(self, image):
        """
        Masks clouds, cloud shadows, snow, and saturated pixels in Landsat images using the `QA_PIXEL` band.

        Parameters:
        image (ee.Image): The input Landsat image.

        Returns:
        ee.Image: The image with cloud and saturation pixels masked.
        """
        qamask = image.select('QA_PIXEL').bitwiseAnd(int('11111', 2)).eq(0)
        saturationmask = image.select('QA_RADSAT').eq(0)
        return image.updateMask(qamask).updateMask(saturationmask)


    def harmonizeBands(self, image):
        """
        Harmonizes band selection by removing `SR_QA_AEROSOL` if present.

        Parameters:
        image (ee.Image): The input Landsat image.

        Returns:
        ee.Image: The image with consistent band names across sensors.
        """
        bands = image.bandNames()
        filtered = ee.Algorithms.If(
            bands.contains('SR_QA_AEROSOL'),
            image.select(bands.remove('SR_QA_AEROSOL')),
            image
        )
        return ee.Image(filtered)


    def get_INDEX(self, image, sensor):
        """
        Computes NDVI and NBR indices for a Landsat image.

        Parameters:
        image (ee.Image): The input Landsat image.
        sensor (str): The Landsat sensor type ('L5', 'L7', 'L8', 'L9').

        Returns:
        ee.Image: The image with NDVI and NBR bands added.
        """
        bands_dict = {
            'L5': {'NIR': 'SR_B4', 'Red': 'SR_B3', 'SWIR2': 'SR_B7'},
            'L7': {'NIR': 'SR_B4', 'Red': 'SR_B3', 'SWIR2': 'SR_B7'},
            'L8': {'NIR': 'SR_B5', 'Red': 'SR_B4', 'SWIR2': 'SR_B7'},
            'L9': {'NIR': 'SR_B5', 'Red': 'SR_B4', 'SWIR2': 'SR_B7'}
        }
        bands = bands_dict[sensor]

        NDVI = image.expression(
            '(NIR - Red) / (NIR + Red)',
            {'NIR': image.select(bands['NIR']), 'Red': image.select(bands['Red'])}
        ).rename('NDVI')

        NBR = image.expression(
            '((NIR - SWIR2) / (NIR + SWIR2)) * 1000',
            {'NIR': image.select(bands['NIR']), 'SWIR2': image.select(bands['SWIR2'])}
        ).rename('NBR')

        return image.addBands(NDVI).addBands(NBR)


    def renameBands(self, image, sensor):
        """
        Renames bands to maintain consistency across different Landsat sensors.

        Parameters:
        image (ee.Image): The input Landsat image.
        sensor (str): The Landsat sensor type ('L5', 'L7', 'L8', 'L9').

        Returns:
        ee.Image: The image with renamed bands.
        """
        bands_dict = {
            'L5': ['SR_B1', 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B7', 'NDVI', 'NBR', 'QA_PIXEL'],
            'L7': ['SR_B1', 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B7', 'NDVI', 'NBR', 'QA_PIXEL'],
            'L8': ['SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B6', 'SR_B7', 'NDVI', 'NBR', 'QA_PIXEL'],
            'L9': ['SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B6', 'SR_B7', 'NDVI', 'NBR', 'QA_PIXEL']
        }
        bands = bands_dict[sensor]
        new_bands = ['B', 'G', 'R', 'NIR', 'SWIR1', 'SWIR2', 'NDVI', 'NBR', 'QA_PIXEL']

        available_bands = image.bandNames()
        has_qa_pixel = available_bands.contains('QA_PIXEL')

        return ee.Algorithms.If(
            has_qa_pixel,
            image.select(bands).rename(new_bands),
            image.select(bands[:-1]).rename(new_bands[:-1])
        )

    def adddate(self, image):
        """
        Adds the 'time_start' property to an Earth Engine image.

        Parameters:
        image (ee.Image): The input Earth Engine image.

        Returns:
        ee.Image: The image with the 'time_start' property set.
        """
        return image.set('time_start', image.get('system:time_start'))

    def get_fire_images(self, start_date, end_date, buffer_distance):
        area = max(self.area_input.value(), 0.0001)  
        #buffer_size = ee.Number(area).log().multiply(3000).max(3000) 
        buffer_size = ee.Number(163673.1).multiply(ee.Number(1).subtract(ee.Number(-0.001157413).multiply(ee.Number(area).pow(0.5259879)).exp()))  
        region = ee.Geometry.Point([self.ignition_point.x(), self.ignition_point.y()]).buffer(buffer_size)
        
        L5_col = ee.ImageCollection('LANDSAT/LT05/C02/T1_L2') \
            .map(self.applyScaleFactors).map(self.harmonizeBands).map(self.maskClouds) \
            .map(lambda img: self.get_INDEX(img, 'L5')) \
            .map(lambda img: self.renameBands(img, 'L5'))

        L7_col = ee.ImageCollection('LANDSAT/LE07/C02/T1_L2') \
            .filterDate('1999-01-01', '2003-05-31') \
            .map(self.applyScaleFactors).map(self.harmonizeBands).map(self.maskClouds) \
            .map(lambda img: self.get_INDEX(img, 'L7')) \
            .map(lambda img: self.renameBands(img, 'L7'))

        L8_col = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2') \
            .map(self.applyScaleFactors).map(self.harmonizeBands).map(self.maskClouds) \
            .map(lambda img: self.get_INDEX(img, 'L8')) \
            .map(lambda img: self.renameBands(img, 'L8'))

        L9_col = ee.ImageCollection('LANDSAT/LC09/C02/T1_L2') \
            .map(self.applyScaleFactors).map(self.harmonizeBands).map(self.maskClouds) \
            .map(lambda img: self.get_INDEX(img, 'L9')) \
            .map(lambda img: self.renameBands(img, 'L9'))

        sat = L5_col.merge(L7_col).merge(L8_col).merge(L9_col)

        mosaicpre = sat.filterBounds(region).filterDate(ee.Date(start_date).advance(-365, 'day'), ee.Date(start_date)).map(lambda img: self.adddate(img)).sort('system:time_start', True)
        mosaicpos = sat.filterBounds(region).filterDate(ee.Date(end_date), ee.Date(end_date).advance(180, 'day')).map(lambda img: self.adddate(img)).sort('system:time_start', False)

        pref = mosaicpre.mosaic().clip(region)
        postf = mosaicpos.mosaic().clip(region)

        PREImagen = pref.select(['R', 'G', 'B', 'NIR', 'SWIR1', 'SWIR2', 'NDVI', 'NBR', 'QA_PIXEL']).toFloat()
        POSImagen = postf.select(['R', 'G', 'B', 'NIR', 'SWIR1', 'SWIR2', 'NDVI', 'NBR', 'QA_PIXEL']).toFloat()
        
        temp_dir = tempfile.gettempdir()
        pre_path = os.path.join(temp_dir, f"ImgPreF_{start_date}.tif")
        post_path = os.path.join(temp_dir, f"ImgPosF_{end_date}.tif")

        print(f"üíæ Descargando im√°genes en archivos temporales: {pre_path} y {post_path}")

        pre_url = PREImagen.getDownloadUrl({
            'scale': 30,
            'bands': ['R', 'G', 'B', 'NIR', 'SWIR1', 'SWIR2', 'NDVI', 'NBR', 'QA_PIXEL'],
            'region': region.bounds().getInfo()['coordinates'],
            'crs': 'EPSG:4326',
            'format': 'GeoTIFF'
        })

        post_url = POSImagen.getDownloadUrl({
            'scale': 30,
            'bands': ['R', 'G', 'B', 'NIR', 'SWIR1', 'SWIR2', 'NDVI', 'NBR', 'QA_PIXEL'],
            'region': region.bounds().getInfo()['coordinates'],
            'crs': 'EPSG:4326',
            'format': 'GeoTIFF'
        })

        
        def download_image(url, output_path):
            response = requests.get(url, stream=True)
            if response.status_code == 200:
                with open(output_path, 'wb') as file:
                    for chunk in response.iter_content(1024):
                        file.write(chunk)
                print(f"‚úÖ Imagen descargada: {output_path}")
                return True
            else:
                print(f"‚ö†Ô∏è Error al descargar la imagen: {url}")
                return False

        success_pre = download_image(pre_url, pre_path)
        success_post = download_image(post_url, post_path)

        if success_pre and success_post:
            self.add_raster_to_qgis(pre_path, f"Pre-Fire {start_date}")
            self.add_raster_to_qgis(post_path, f"Post-Fire {end_date}")

        print("‚úÖ Descarga de im√°genes temporales completada y agregadas a QGIS.")

    def add_raster_to_qgis(self, file_path, layer_name):
        """
        Agrega un archivo TIFF a la interfaz de QGIS.

        Parameters:
        file_path (str): Ruta del archivo TIFF.
        layer_name (str): Nombre de la capa en QGIS.
        """
        if os.path.exists(file_path):
            layer = QgsRasterLayer(file_path, layer_name, "gdal")
            if layer.isValid():
                QgsProject.instance().addMapLayer(layer)
                print(f"üó∫Ô∏è Capa agregada a QGIS: {layer_name}")
            else:
                print(f"‚ö†Ô∏è Error: No se pudo cargar la capa {layer_name}")
        else:
            print(f"‚ö†Ô∏è El archivo no existe: {file_path}")